<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 函数作用域
    var myObject = (function () {
      var _name = 'sven';
      return {
        getName: function () {
          return _name;
        }
      }
    })();

    console.dir(myObject.getName());

    /*
    上一节描述的封装，指的是数据层面的封装。
    有时候我们喜欢把封装等同于封装数据，但这是一种比较狭义的定义。
    封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。
    从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。
    其他对象或者用户都不关心它的内部实现。
    封装使得对象之间的耦合变松散，对象之间只通过暴露的API接口来通信。
    当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。
    封装实现细节的例子非常之多。
    拿迭代器来说明，迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。
    我们编写了一个each函数，它的作用就是遍历一个聚合对象，使用这个each函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。
    即使each函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。
    */
  </script>
</body>

</html>