<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
      经过思考，我们想到了更好的办法——使用策略模式来重构代码。
      策略模式指的是定义一系列的算法，把它们一个个封装起来。
      将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来
      在这个例子里，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。
      而算法的实现是各异和变化的，每种绩效对应着不同的计算规则。
      一个基于策略模式的程序至少由两部分组成。
      第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
      第二个部分是环境类Context, Context接受客户的请求，随后把请求委托给某一个策略类。
      要做到这点，说明Context中要维持对某个策略对象的引用。
    */

    var PerformanceS = function () {

    }

    PerformanceS.prototype.calculate = function (salary) {
      return salary * 4;
    }

    var PerformanceA = function () {

    }

    PerformanceA.prototype.calculate = function (salary) {
      return salary * 3;
    }

    var PerformanceB = function () {

    }

    PerformanceB.prototype.calculate = function (salary) {
      return salary * 2;
    }

    var Bonus = function () {
      this.salary = null;
      this.strategy = null;
    }

    Bonus.prototype.setSalary = function (salary) {
      this.salary = salary;
    }

    Bonus.prototype.setStrategy = function (strategy) {
      this.strategy = strategy;
    }

    Bonus.prototype.getBonus = function () {
      return this.strategy.calculate(this.salary);
    }

    var bonus = new Bonus();

    bonus.setSalary(1000);
    bonus.setStrategy(new PerformanceS());

    console.log(bonus.getBonus());

    bonus.setStrategy(new PerformanceA());
    console.log(bonus.getBonus());

  </script>
</body>

</html>