<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    function SuperType() {
      this.colors = ['red', 'blue', 'green'];
    }

    function SubType() {
    }

    SubType.prototype = new SuperType();
    const instance1 = new SubType();
    instance1.colors.push('black');

    const instance2 = new SubType();
    console.log(instance2.colors);
    /* 1.给SuperType构造函数定义了一个colors属性,该属性包含一个数组(引用类型值)
       SuperType的每个实例都会有各自包含自己数组的colors属性。
       当SubType通过原型链继承了SuperType之后，SubType.prototype就变成了SuperType的一个实例
       因此她也拥有了一个它自己colors属性
       2.在创建子类型的实例时，不能像超类型的构造函数中传递参数。实际上应该说是没有办法再不影响所有对象实例的情况下，
       给超类型的构造函数传递参数。实践中很少会单独使用原型链。
    */

  </script>
</body>

</html>